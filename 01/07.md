### ✍️ Tangxt ⏳ 2021-12-23 🏷️ uni-app

# 第 7 章 全局状态管理

1）开篇

在上一章中我们完成了 “一半” 的文章搜索功能，并且留下了一些问题。那么这些历史残留的问题，我们将会在本章节中通过 **全局状态管理工具** 进行处理。

那么究竟什么是 **全局状态管理工具**呢？我们又如何在 `uniapp` 中使用 全局状态管理工具来解决我们的问题呢？，在完成我们剩下的 文章搜索功能 的时候，我们是否还会再遇到其他的坑呢？

这些内容我们都会在本章节中为大家一一讲解。

2）状态管理 - 全局状态管理工具

> 老套路，接触一个新知识，还是得先从「为什么要学习它」，然后「针对它提出你的疑问」，最后「带着你的疑问在学习它的时候去解决这些疑问」 -> 终极目的：应用到你的项目中！

1、场景

在上一章中，我们遇到了一个问题：**`search-blog` 和 `search-history`、`searchData` 和 组件** 之间 **强耦合** 。

如果想要解决这个问题，那么我们需要使用到一个叫做：**全局状态管理工具** 的东西。

学习过 `vue` 的同学应该知道，在 `vue` 中，存在一个 [vuex](https://vuex.vuejs.org/zh/)  的库，这个库的作用就是：**全局状态管理**。

而在 `uniapp` 里，如果我们想要实现 **全局状态管理**，那么 [vuex](https://vuex.vuejs.org/zh/) 也将是一个非常好的选择。

那么下面我们就来看一下，什么是 **全局状态管理工具**，以及什么是 [vuex](https://vuex.vuejs.org/zh/) 

2、问题

> 1. 什么是全局状态管理模式 和 什么是全局状态管理工具
> 2. 什么是 vuex

3、知识

明确这两个问题，就开始学习新知识了

**“单向数据流” 理念示意图**

![全局状态管理](assets/img/2021-12-23-14-26-23.png)

这种图表示的是单向数据流这个模型概念

啥意思？当我们的应用运用在用户手中的时候 -> 用户所有的操作，这最终操作的东西是什么呢？ -> 用户直接操作的是视图吗？ -> 其实并不是，对于当前的所有用户而言，用户直接操作的内容其实是我们的数据，当我们的数据发生变化的时候，我们的视图是跟随发生变化的，而视图的跟随发生变化会直接反馈到用户他的这一个操作之中 -> 这样一个模型我们就把它称之为是一个单向的数据流模型

简单来说就是：用户操作 -> 修改数据，数据变化 -> 视图跟随数据发生变化，视图发生变化 -> 反应到用户的眼中来完成用户最初的这个操作

- **state**，驱动应用的数据源；
- **view**，以声明方式将 **state** 映射到视图；
- **actions**，响应在 **view** 上的用户输入导致的状态变化。

---

这是我最初的认识误区：

![认识](assets/img/2021-12-23-14-43-30.png)

---

但是，这样一个单向数据流处理其实在某些情况下会非常危险

比如说：

当我们的应用遇到**多个组件共享状态（数据）**时，单向数据流的简洁性很容易被破坏（回忆 `search-blog` 和 `search-history` 的代码，`searchData`这个数据在这两个组件里边都有被访问到） -> 破坏的原因是：

- 多个视图依赖于同一状态（数据）
- 来自不同视图的行为需要变更同一状态（数据）

![数据](assets/img/2021-12-23-14-51-26.png)

我们在这两个组件里边分别对这个数据做不同的操作 -> 这种不同行为，影响了同一个数据的变化

为了解决这个问题

所以我们不得不通过 **父子组件传递数据** 的方式，来频繁的修改状态（数据）：

![父子通信](assets/img/2021-12-23-14-54-43.png)

但是这种方式是 **非常脆弱，通常会导致无法维护的代码。**

说白了就是组件之间的耦合性太强了

那如何解决呢？ -> 必须使用全局状态管理模式

💡：什么是全局状态管理模式？

![全局状态管理工具](assets/img/2021-12-23-15-00-38.png)

 > 全局状态管理模式：**把多个组件之中共用的数据给抽离出来，也就是抽离到一个单独的地方，然后通过一个 单例模式 去进行管理**，而这种管理的方式就叫做【全局状态管理模式】。（关于全局状态的一个管理模式）

而具备 【全局状态管理模式】 的库，我们就把它称之为：【全局状态管理工具】

而在 `vue` 中存在一个专门的 【全局状态管理工具】，叫做 `vuex`。

因为 `uniapp` 其实追随了 `vue` 和 `微信小程序` 的语法，所以我们可以在 `uniapp` 中使用 `vuex` 来进行 【全局状态管理】，并且这是一个 **非常被推荐** 的选择。

明确了这些概念之后，就来看一下之前我们描述的问题

4、答案

问题 1：

![问题 1](assets/img/2021-12-23-15-03-08.png)

问题 2：

![问题 2](assets/img/2021-12-23-15-04-54.png)

学到了啥？

- 全局状态管理工具的概念是啥？
- 接触到的新工具：Vuex

👇：使用 Vuex 管理我们整个项目中的所有共享数据！

3）状态管理 - 在项目中导入 vuex

使用 vuex 分成两大步：

1. 创建`store`模块
2. 在`main.js`中注册`vuex`插件

实现：

1. 定位到根目录 -> 创建`store/index.js` -> 这个文件就是`store`模块
   1. 导入`vue`和`vuex`
   2. 安装`vuex`插件
   3. 创建`store`实例
2. 在`main.js`的`new Vue({})`的`{}`里边挂载`store`实例

> [Demo](https://github.com/ppambler/imooc-uni-app/commit/dfbc296)

4）状态管理 - 测试 vuex 是否导入成功

测试 vuex 是否可以正常使用，测试的方式一共分成了三步：

1. 创建一个单独的模块：`modules/search.js` -> 用来表示当前 vuex 中的模块
2. 在 `index.js` 中注入（或者说绑定）这个模块
3. 在 `search-blog` 中使用 模块中的数据 -> 看一下我们模块里边的数据是否可以被正常访问 -> 可以被正常访问，意味着我们当前的 vuex 已经导入成功了

![全局数据](assets/img/2021-12-23-17-31-49.png)

> [Demo](https://github.com/ppambler/imooc-uni-app/commit/0534bef)

➹：[vuex namespaced 的作用以及使用方式](https://blog.csdn.net/fuck487/article/details/83411856)

👇：让`searchData`这个数据和我们的组件解耦

5）状态管理 - 构建 search 模块

在这个 `vuex` 模块里边，我们已经拥有了`searchData`这个数据，也拥有了三个可以修改它的`mutation`：

1. 添加数据
2. 删除指定数据
3. 删除所有数据

> [Demo](https://github.com/ppambler/imooc-uni-app/commit/191910d)

明确了`search`模块的`mutation`后，接下来就是实现关于`search`模块的数据管理

6）状态管理 - 使用 search 模块完成搜索历史管理

![搜索历史管理](assets/img/2021-12-23-21-19-38.png)

> [Demo](https://github.com/ppambler/imooc-uni-app/commit/1cf403e)

至此，我们就已经使用 vuex 来分离了我们的数据`searchData`和我们的业务组件（`search-blog`和`search-history`）

数据都被 `vuex` 中的 `search`模块去管理，而所有的业务逻辑都被我们的组件调用 -> 目前的`searchData`数据和我们的组件之间已经没有任何关系了 -> 说白了，我们**已经完成了数据和组件业务的一个解耦**

👇：数据持久化

7）状态管理 - 数据持久化

这是搜素历史的最后一个功能

目前，由于基本已完成数据和组件的分离，所以【数据持久化】不会涉及到组件内的代码，也就是整个「数据持久化」操作在`search`模块里边就可以完成了

数据持久化，分成两块部分：

1. 数据的保存
2. 数据的读取

数据保存后再读取出来，这个「持久化」功能就完成了！

> 保存方式跟 localStorage 没啥区别，都是一个`key`，一个`value`
> 
> `localStorage.setItem("data", JSON.stringify(data))` 和 `localStorage.getItem("data")`
> 
> `uni.setStorage({key: 'xxx', data: [] })` （可以保存多种类型的数据，而 localStorage 会把值自动转化为字符串）和 `uni.getStorageSync('xxx')`

数据持久化搞定后，不管你怎么重新编译，只要有搜索历史，那么这个搜索历史始终都会存在，当然，除非你把对应的`key`的本地存储给清空了

![数据持久化](assets/img/2021-12-23-22-14-05.png)

> [Demo](https://github.com/ppambler/imooc-uni-app/commit/6f78321)

三个模块中已完成两个 -> 最后一个「搜索结果」模块

👇：处理搜索结果的逻辑展示

8）搜索结果 - 获取搜索结果数据
